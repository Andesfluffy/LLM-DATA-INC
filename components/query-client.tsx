"use client";

import { useCallback, useEffect, useMemo, useState } from "react";
import { ChevronDown, ChevronRight, Sparkles, FileDown } from "lucide-react";

import Card, { CardBody, CardHeader } from "@/src/components/Card";
import Button from "@/src/components/Button";
import ErrorAlert from "@/components/ui/error-alert";
import Table from "@/src/components/Table";
import Textarea from "@/src/components/ui/Textarea";
import { TableSkeleton } from "@/components/ui/skeleton";
import AnalysisChart, { type ChartConfig } from "@/src/components/AnalysisChart";
import { fetchAccessibleDataSources } from "@/src/lib/datasourceClient";

type QueryClientProps = { canRun: boolean };
type Row = Record<string, unknown>;
type ConnectionIds = { datasourceId: string };
type Briefing = { description: string; suggestions: string[] };
type AnalyzeResult = {
  sql: string;
  fields: string[];
  rows: Row[];
  insight: string;
  chart: ChartConfig | null;
};

// ── Print-only report component ───────────────────────────────────────────
function PrintReport({
  question,
  insight,
  chart,
  rows,
  fields,
}: {
  question: string;
  insight: string;
  chart: ChartConfig | null;
  rows: Row[];
  fields: string[];
}) {
  const date = new Date().toLocaleDateString("en-US", {
    weekday: "long",
    year: "numeric",
    month: "long",
    day: "numeric",
  });

  return (
    <div style={{ fontFamily: "system-ui, Arial, sans-serif", color: "#111827", padding: 0 }}>
      {/* Header */}
      <div style={{ display: "flex", justifyContent: "space-between", alignItems: "flex-start", borderBottom: "2px solid #e5e7eb", paddingBottom: 14, marginBottom: 24 }}>
        <div>
          <h1 style={{ fontSize: 22, fontWeight: 700, margin: 0, color: "#111827" }}>Data Analysis Report</h1>
          <p style={{ fontSize: 12, color: "#6b7280", margin: "4px 0 0" }}>{date}</p>
        </div>
        <p style={{ fontSize: 11, color: "#9ca3af", margin: 0, alignSelf: "center" }}>
          Generated by LLM Data Inc
        </p>
      </div>

      {/* Question */}
      <div style={{ marginBottom: 20 }}>
        <p style={{ fontSize: 10, fontWeight: 600, textTransform: "uppercase", letterSpacing: "0.06em", color: "#9ca3af", margin: "0 0 6px" }}>
          Question
        </p>
        <p style={{ fontSize: 16, fontWeight: 600, color: "#1f2937", margin: 0, lineHeight: 1.4 }}>
          {question}
        </p>
      </div>

      {/* Insight */}
      <div
        className="print-keep-together"
        style={{ background: "#fff7ed", borderLeft: "4px solid #f97316", borderRadius: 4, padding: "14px 16px", marginBottom: 28 }}
      >
        <p style={{ fontSize: 10, fontWeight: 600, textTransform: "uppercase", letterSpacing: "0.06em", color: "#9ca3af", margin: "0 0 8px" }}>
          Analysis Summary
        </p>
        <p style={{ fontSize: 14, lineHeight: 1.7, color: "#1f2937", margin: 0 }}>{insight}</p>
      </div>

      {/* Chart */}
      {chart && (
        <div className="print-keep-together" style={{ marginBottom: 28 }}>
          <p style={{ fontSize: 10, fontWeight: 600, textTransform: "uppercase", letterSpacing: "0.06em", color: "#9ca3af", margin: "0 0 10px" }}>
            Visualisation — {chart.title}
          </p>
          <AnalysisChart config={chart} rows={rows} printMode />
        </div>
      )}

      {/* Data table */}
      {rows.length > 0 && fields.length > 0 && (
        <div className="print-keep-together">
          <p style={{ fontSize: 10, fontWeight: 600, textTransform: "uppercase", letterSpacing: "0.06em", color: "#9ca3af", margin: "0 0 10px" }}>
            Data — {rows.length} rows{rows.length > 30 ? " (first 30 shown)" : ""}
          </p>
          <table style={{ width: "100%", borderCollapse: "collapse", fontSize: 11 }}>
            <thead>
              <tr>
                {fields.map((f) => (
                  <th
                    key={f}
                    style={{ textAlign: "left", padding: "7px 10px", background: "#f3f4f6", border: "1px solid #e5e7eb", fontWeight: 600, color: "#374151" }}
                  >
                    {f}
                  </th>
                ))}
              </tr>
            </thead>
            <tbody>
              {rows.slice(0, 30).map((r, i) => (
                <tr key={i} style={{ background: i % 2 ? "#f9fafb" : "#ffffff" }}>
                  {fields.map((f) => (
                    <td
                      key={f}
                      style={{ padding: "5px 10px", border: "1px solid #e5e7eb", color: "#374151" }}
                    >
                      {String(r[f] ?? "")}
                    </td>
                  ))}
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      )}

      {/* Footer */}
      <div style={{ marginTop: 32, paddingTop: 12, borderTop: "1px solid #e5e7eb", textAlign: "center" }}>
        <p style={{ fontSize: 11, color: "#9ca3af", margin: 0 }}>
          Confidential · LLM Data Inc · {new Date().getFullYear()}
        </p>
      </div>
    </div>
  );
}

// ── Main component ────────────────────────────────────────────────────────
export default function QueryClient({ canRun }: QueryClientProps) {
  const [prompt, setPrompt] = useState("");
  const [error, setError] = useState<string | null>(null);
  const [isAnalyzing, setIsAnalyzing] = useState(false);

  const [briefing, setBriefing] = useState<Briefing | null>(null);
  const [isBriefingLoading, setIsBriefingLoading] = useState(false);
  const [offTopic, setOffTopic] = useState<{ reason: string } | null>(null);

  const [analyzeResult, setAnalyzeResult] = useState<AnalyzeResult | null>(null);
  const [editableSql, setEditableSql] = useState("");
  const [showSql, setShowSql] = useState(false);
  const [showTable, setShowTable] = useState(false);
  const [isRerunning, setIsRerunning] = useState(false);

  const ensureConnectionIds = useCallback(async (): Promise<ConnectionIds | null> => {
    try {
      let datasourceId = localStorage.getItem("datasourceId");
      if (!datasourceId) {
        const list = await fetchAccessibleDataSources();
        if (list.length > 0) {
          datasourceId = list[0]!.id;
          localStorage.setItem("datasourceId", datasourceId);
        }
      }
      if (datasourceId) return { datasourceId };
    } catch (err) {
      setError(err instanceof Error ? err.message : String(err));
    }
    setError("Please save a data source in Settings.");
    return null;
  }, []);

  const getIdToken = useCallback(async () => {
    const { auth } = await import("@/lib/firebase/client");
    return auth.currentUser?.getIdToken() ?? undefined;
  }, []);

  // ── Proactive briefing ────────────────────────────────────────────────
  useEffect(() => {
    let cancelled = false;
    (async () => {
      const ids = await ensureConnectionIds();
      if (!ids || cancelled) return;
      setIsBriefingLoading(true);
      try {
        const idToken = await getIdToken();
        const resp = await fetch("/api/datasources/suggest", {
          method: "POST",
          headers: { "Content-Type": "application/json", ...(idToken ? { Authorization: `Bearer ${idToken}` } : {}) },
          body: JSON.stringify({ datasourceId: ids.datasourceId }),
        });
        if (resp.ok && !cancelled) setBriefing((await resp.json()) as Briefing);
      } catch { /* non-critical */ } finally {
        if (!cancelled) setIsBriefingLoading(false);
      }
    })();
    return () => { cancelled = true; };
  }, []); // eslint-disable-line react-hooks/exhaustive-deps

  // ── Analyze ──────────────────────────────────────────────────────────
  const handleAnalyze = useCallback(async () => {
    const trimmed = prompt.trim();
    if (!trimmed) return;
    setIsAnalyzing(true);
    setError(null);
    setOffTopic(null);
    setAnalyzeResult(null);
    setShowSql(false);
    setShowTable(false);
    try {
      const ids = await ensureConnectionIds();
      if (!ids) return;
      const idToken = await getIdToken();
      const resp = await fetch("/api/analyze", {
        method: "POST",
        headers: { "Content-Type": "application/json", ...(idToken ? { Authorization: `Bearer ${idToken}` } : {}) },
        body: JSON.stringify({ datasourceId: ids.datasourceId, prompt: trimmed }),
      });
      const data = await resp.json();
      if (!resp.ok) throw new Error(data?.error ?? "Analysis failed");
      if (data.offTopic) { setOffTopic({ reason: data.reason }); return; }
      const result = data as AnalyzeResult;
      setAnalyzeResult(result);
      setEditableSql(result.sql);
    } catch (err) {
      setError(err instanceof Error ? err.message : String(err));
    } finally {
      setIsAnalyzing(false);
    }
  }, [ensureConnectionIds, getIdToken, prompt]);

  // ── Re-run edited SQL ─────────────────────────────────────────────────
  const handleRerun = useCallback(async () => {
    const trimmed = editableSql.trim();
    if (!trimmed) return;
    setIsRerunning(true);
    setError(null);
    try {
      const ids = await ensureConnectionIds();
      if (!ids) return;
      const idToken = await getIdToken();
      const resp = await fetch("/api/execute", {
        method: "POST",
        headers: { "Content-Type": "application/json", ...(idToken ? { Authorization: `Bearer ${idToken}` } : {}) },
        body: JSON.stringify({ datasourceId: ids.datasourceId, sql: trimmed }),
      });
      const data = await resp.json();
      if (!resp.ok) throw new Error(data?.error ?? "Query failed");
      setAnalyzeResult((prev) =>
        prev ? { ...prev, sql: trimmed, fields: data.fields, rows: data.rows } : null
      );
    } catch (err) {
      setError(err instanceof Error ? err.message : String(err));
    } finally {
      setIsRerunning(false);
    }
  }, [editableSql, ensureConnectionIds, getIdToken]);

  // ── Export CSV ────────────────────────────────────────────────────────
  const handleExportCsv = useCallback(() => {
    if (!analyzeResult?.rows.length) return;
    const { fields, rows } = analyzeResult;
    const csv = [
      fields.join(","),
      ...rows.map((r) => fields.map((f) => JSON.stringify(r[f] ?? "")).join(",")),
    ].join("\n");
    const blob = new Blob([csv], { type: "text/csv" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${prompt.slice(0, 40).replace(/[^a-z0-9]/gi, "_")}.csv`;
    a.click();
    URL.revokeObjectURL(url);
  }, [analyzeResult, prompt]);

  // ── Download PDF (browser print-to-PDF) ──────────────────────────────
  const handleDownloadPdf = useCallback(() => {
    const prev = document.title;
    document.title = prompt.slice(0, 60) || "Analysis Report";
    window.print();
    // restore after print dialog closes (slight delay)
    setTimeout(() => { document.title = prev; }, 1000);
  }, [prompt]);

  const fields = useMemo(
    () => (analyzeResult?.rows[0] ? Object.keys(analyzeResult.rows[0]) : analyzeResult?.fields ?? []),
    [analyzeResult]
  );

  return (
    <>
      {/* ── Everything hidden on print ── */}
      <div className="no-print space-y-6">

        {/* Ask */}
        <Card>
          <CardHeader title="Ask a question" subtitle="Instant analysis — insight, chart, and data in one step" />
          <CardBody className="space-y-4">

            {/* Briefing */}
            {isBriefingLoading && (
              <div className="rounded-lg border border-slate-700 bg-slate-800/50 p-4 space-y-2">
                <div className="h-3 w-2/3 animate-pulse rounded bg-slate-700" />
                <div className="h-2.5 w-full animate-pulse rounded bg-slate-700" />
                <div className="h-2.5 w-4/5 animate-pulse rounded bg-slate-700" />
              </div>
            )}

            {briefing && !isBriefingLoading && (
              <div className="rounded-lg border border-accent/20 bg-accent/5 p-4 space-y-3">
                <p className="text-sm text-slate-300 leading-relaxed">{briefing.description}</p>
                {briefing.suggestions.length > 0 && (
                  <div className="space-y-1.5">
                    <p className="text-xs font-semibold uppercase tracking-wide text-slate-500">Try asking</p>
                    {briefing.suggestions.map((s, i) => (
                      <button
                        key={i}
                        type="button"
                        onClick={() => { setPrompt(s); setOffTopic(null); setError(null); }}
                        className="block text-left text-sm text-accent/90 hover:text-accent hover:underline underline-offset-2 transition-colors"
                      >
                        {s}
                      </button>
                    ))}
                  </div>
                )}
              </div>
            )}

            {/* Input */}
            <div className="space-y-3">
              <label className="block text-sm font-medium text-gray-300" htmlFor="query-prompt">
                Question
              </label>
              <Textarea
                id="query-prompt"
                value={prompt}
                onChange={(e) => { setPrompt(e.target.value); if (offTopic) setOffTopic(null); }}
                rows={3}
                placeholder="e.g. In the last 3 months, which county had the highest crimes vs the lowest?"
                onKeyDown={(e) => { if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); handleAnalyze(); } }}
              />
              <Button onClick={handleAnalyze} disabled={!canRun || isAnalyzing || !prompt.trim()} className="w-full sm:w-auto">
                <Sparkles className="mr-1.5 h-4 w-4" />
                {isAnalyzing ? "Analyzing…" : "Analyze"}
              </Button>
            </div>

            {/* Off-topic */}
            {offTopic && (
              <div className="rounded-lg border border-amber-500/25 bg-amber-500/5 p-4 space-y-3">
                <p className="text-sm font-semibold text-amber-400">That question isn&apos;t in your connected data.</p>
                {offTopic.reason && <p className="text-xs text-slate-400 leading-relaxed">{offTopic.reason}</p>}
                {briefing && briefing.suggestions.length > 0 && (
                  <div className="space-y-1.5">
                    <p className="text-xs font-semibold uppercase tracking-wide text-slate-500">Try these instead</p>
                    {briefing.suggestions.slice(0, 3).map((s, i) => (
                      <button key={i} type="button"
                        onClick={() => { setPrompt(s); setOffTopic(null); setError(null); }}
                        className="block text-left text-sm text-accent/90 hover:text-accent hover:underline underline-offset-2 transition-colors"
                      >{s}</button>
                    ))}
                  </div>
                )}
              </div>
            )}

            {error && <ErrorAlert message={error} className="mt-2" aria-live="polite" />}
          </CardBody>
        </Card>

        {/* Loading skeleton */}
        {isAnalyzing && (
          <Card>
            <CardBody className="space-y-4">
              <div className="space-y-2">
                <div className="h-3 w-1/3 animate-pulse rounded bg-slate-700" />
                <div className="h-3 w-2/3 animate-pulse rounded bg-slate-700" />
                <div className="h-3 w-1/2 animate-pulse rounded bg-slate-700" />
              </div>
              <TableSkeleton rows={5} cols={4} />
            </CardBody>
          </Card>
        )}

        {/* Results */}
        {analyzeResult && !isAnalyzing && (
          <Card>
            <CardBody className="space-y-5">

              {/* Insight */}
              <div className="rounded-lg border border-accent/15 bg-accent/5 p-4">
                <p className="mb-1.5 text-xs font-semibold uppercase tracking-wide text-accent/70">Analysis</p>
                <p className="text-sm leading-relaxed text-slate-200">{analyzeResult.insight}</p>
              </div>

              {/* Chart */}
              {analyzeResult.chart && (
                <AnalysisChart config={analyzeResult.chart} rows={analyzeResult.rows} />
              )}

              {/* Actions */}
              <div className="flex flex-wrap gap-2">
                <Button
                  variant="secondary"
                  onClick={handleDownloadPdf}
                  className="text-xs gap-1.5"
                >
                  <FileDown className="h-3.5 w-3.5" />
                  Download PDF
                </Button>
                {analyzeResult.rows.length > 0 && (
                  <Button variant="secondary" onClick={handleExportCsv} className="text-xs">
                    Export CSV
                  </Button>
                )}
              </div>

              {/* Raw data (collapsible) */}
              <div className="border-t border-white/[0.06] pt-4">
                <button
                  type="button"
                  onClick={() => setShowTable((v) => !v)}
                  className="flex items-center gap-1.5 text-sm font-medium text-slate-400 hover:text-slate-200 transition-colors"
                >
                  {showTable ? <ChevronDown className="h-4 w-4" /> : <ChevronRight className="h-4 w-4" />}
                  Raw data
                  <span className="ml-1 rounded-full bg-slate-700 px-2 py-0.5 text-xs text-slate-400">
                    {analyzeResult.rows.length} rows
                  </span>
                </button>
                {showTable && analyzeResult.rows.length > 0 && (
                  <div className="mt-3"><Table fields={fields} rows={analyzeResult.rows} /></div>
                )}
              </div>

              {/* SQL (collapsible) */}
              <div className="border-t border-white/[0.06] pt-4">
                <button
                  type="button"
                  onClick={() => setShowSql((v) => !v)}
                  className="flex items-center gap-1.5 text-sm font-medium text-slate-400 hover:text-slate-200 transition-colors"
                >
                  {showSql ? <ChevronDown className="h-4 w-4" /> : <ChevronRight className="h-4 w-4" />}
                  SQL
                </button>
                {showSql && (
                  <div className="mt-3 space-y-2">
                    <Textarea value={editableSql} onChange={(e) => setEditableSql(e.target.value)} rows={6} aria-label="Generated SQL" />
                    <Button onClick={handleRerun} disabled={!canRun || isRerunning || !editableSql.trim()} variant="secondary" className="text-xs">
                      {isRerunning ? "Running…" : "Re-run SQL"}
                    </Button>
                  </div>
                )}
              </div>

            </CardBody>
          </Card>
        )}
      </div>

      {/* ── Print-only report (hidden on screen) ── */}
      {analyzeResult && (
        <div className="print-only hidden">
          <PrintReport
            question={prompt}
            insight={analyzeResult.insight}
            chart={analyzeResult.chart}
            rows={analyzeResult.rows}
            fields={fields}
          />
        </div>
      )}
    </>
  );
}
